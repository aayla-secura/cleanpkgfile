#!/usr/bin/perl
#
##################################################################################################
# Copyright 2014 Aleksandrina Nikolova <aayla.secura.1138@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
##################################################################################################
#
# A script to "clean" package.* files:
#   joins entries referring to the same package-version(s),
#   removes duplicate and invalid USE flags, keywords, env files; sorts them, etc.
#   commented lines are ignored
#   ignores lines between matching '#IGNORE#' lines

require 5.006001;

use Getopt::Long qw{:config bundling gnu_compat no_auto_abbrev
		    no_ignore_case_always permute pass_through};
use Cwd;
use POSIX qw/ strftime floor /;
use File::Basename;
use File::Find::Rule;
use File::Spec::Functions qw/ catdir catfile /;
use File::Temp qw/ tempfile /;
use File::Copy qw/ cp mv /;
use Term::ANSIColor;
use Scalar::Util qw/ openhandle /;
use warnings;
use strict;

sub load_config;
sub process_cmd;
sub check_options;
sub usage;
sub file_preprocess;
sub file_process;

sub get_atom_props;
sub is_installed;
sub get_atom_args;
sub get_valid_atom_args;
sub version_or_slot_matches;
sub version_or_slot_equals;
sub get_lower_version;
sub remove_dup_args (\@;$);

sub not_installed;
sub no_use;
sub invalid_arg;
sub printl;
sub printr;
sub printdbg;
sub printmsg;
sub prompt;

##################################################################################################
############################################## MAIN ##############################################
##################################################################################################

##################################################################################################
my $debug = 0;
my $prog_name = basename $0;
my $verbose = 0;
my $quiet = 0;
my $batch = 0;
my $do_backup = '';
my $force_overwrite = 0;
my $keep_nonmatching = 0;
my $check = '';
my $ignore_use_or_keyword = '';
my $tmp_dir = '/tmp/';
my $help_str = "See $prog_name --help";
my $left_column_width = 22;	# width of left column
my $tab_width = 3;		# separation of left and right columns
my $right_column_width = 85;	# width of right column

{
  my %options;
  %options = (
	      help		=> {
				    long		=> "help",
				    short		=> "h",
				    argument		=> "",
				    allowed_arguments	=> [],
				    description		=> "Print this help message and exit.",
				    variable		=> sub { usage \%options; }
				   },
	      debug		=> {
				    long		=> "debug",
				    short		=> "D",
				    argument		=> "",
				    allowed_arguments	=> [],
				    description		=> "Makes a lot of noise on STDOUT. " .
				    "It also disables prompting the user, so you can pipe the output. " .
				    "Use only if you want to report a bug (or debug yourself).",
				    variable		=> \$debug
				   },
	      verbose		=> {
				    long		=> "verbose",
				    short		=> "v",
				    argument		=> "!",
				    allowed_arguments	=> [],
				    description		=> "Print information about every entry " .
				    "being processed (off by default). Disable with --no-verbose.",
				    variable		=> \$verbose
				   },
	      quiet		=> {
				    long		=> "quiet",
				    short		=> "q",
				    argument		=> "!",
				    allowed_arguments	=> [],
				    description		=> "Do not produce any output - only " .
				    "prompts (off by default). Takes precedence over --verbose. " .
				    "Disable with --no-quiet.",
				    variable		=> \$quiet
				   },
	      batch		=> {
				    long		=> "batch",
				    short		=> "B",
				    argument		=> "!",
				    allowed_arguments	=> [],
				    description		=> "Do not prompt the user - choose " .
				    "default action and force overwrite (off by default). " .
				    "Disable with --no-batch.",
				    variable		=> \$batch
				   },
	      backup		=> {
				    long		=> "backup",
				    short		=> "b",
				    argument		=> "!",
				    allowed_arguments	=> [],
				    description		=> "Backup original files before " .
				    "overwriting (off by default unless --force-overwrite is set). " .
				    "Disable with --no-backup.",
				    variable		=> \$do_backup
				   },
	      force_overwrite	=> {
				    long		=> "force-overwrite",
				    short		=> "f",
				    argument		=> "!",
				    allowed_arguments	=> [],
				    description		=> "Do not prompt to save changes - backup " .
				    "the original file (unless --no-backup is set) and write changes " .
				    "(off by default). Disable with --no-force-overwrite.",
				    variable		=> \$force_overwrite
				   },
	      keep_nonmatching	=> {
				    long		=> "keep-non-matching|keep-nonmatching",
				    short		=> "k",
				    argument		=> "!",
				    allowed_arguments	=> [],
				    description		=> "Do not remove entries with no " .
				    "matching versions installed (off by default). " .
				    "Disable with --no-keep-non-matching|--no-keep-nonmatching.",
				    variable		=> \$keep_nonmatching
				   },
	      check		=> {
				    long		=> "check",
				    short		=> "c",
				    argument		=> "=s",
				    allowed_arguments	=> ['use', 'keyword', 'env', 'guess', 'none', ''],
				    description		=> "Specify the type of the package " .
				    "atom's arguments - 'use', 'keyword', 'env', 'guess' or " .
				    "'none' (default) . Note that this affects behaviour for " .
				    "ALL input files - use 'guess' to guess check from filename" .
				    "/path (useful when specifying multiple files of different " .
				    "type), use the others only if ALL input files are of the " .
				    "specified type.",
				    variable		=> \$check
				   },
	      ignore_use_or_keyword	=> {
				    long		=> "ignore-use-or-keyword",
				    short		=> "i",
				    argument		=> "=s",
				    allowed_arguments	=> [],
				    description		=> "A coma separated list of USE flags or " .
				    "keywords to ignore during check (if checking is to be done). " .
				    "These will NOT be removed even if they are not listed " .
				    "in any of the installed versions matching the package.",
				    variable		=> \$ignore_use_or_keyword
				   },
	      tmp_dir		=> {
				    long		=> "tmp-dir",
				    short		=> "d",
				    argument		=> "=s",
				    allowed_arguments	=> [],
				    description		=> "Directory in which the temporary " .
				    "file will be stored before overwrite (default is /tmp). " .
				    "If set to '' (with --tmp-dir=), the directory of the " .
				    "currently processed file will be used.",
				    variable		=> \$tmp_dir
				   }
	     );
  
  
  # load configuration
  my %config_options = %options{grep { $_ !~ m/^(help|debug)$/ } keys %options};
  load_config \%config_options;
  
  # process command line
  process_cmd \%options;
}

# make sure filename (and no other arguments after option processing) has been specified
die "Please specify at least one filename.\n$help_str\n" unless @ARGV;
printdbg "files: @ARGV";

$verbose = 0 if $quiet;
$check = '' if $check eq 'none';
$batch = 1 if $debug;
$force_overwrite = 1 if $batch && ! $debug;
# unless $do_backup has been explicitly set, $force_overwrite controls it
if ( $do_backup eq '' ) {
  if ( $force_overwrite ) { $do_backup = 1; }
  else { $do_backup = 0; }
}

##################################################################################################
for my $path ( @ARGV ) {
  # make sure tmp_dir is valid and is writable
  my $tmp_dir = $tmp_dir || dirname "$path";
  
  unless ( -d $tmp_dir ) {
    print STDERR color ('bold red');
    print STDERR "No such directory: $tmp_dir\n$help_str\n";
    print STDERR color ('reset');
    next;
  }
  
  unless ( -x $tmp_dir && -r $tmp_dir && -w $tmp_dir ) {
    print STDERR color ('bold red');
    print STDERR "Cannot write to $tmp_dir, check directory permissions.\n";
    print STDERR color ('reset');
    next;
  }
  
  # make sure file exists and is readable
  next unless length $path;
  
  $path = "/etc/portage/$path" unless $path =~ m|/(?!$)|;
  {
    # get full path to file, needed if check is 'guess'
    my $cwd = cwd();
    $path =~ s|^\./|$cwd/|;
  }
  $path =~ s|\./||;
  printdbg "tmp_dir: $tmp_dir", "path: $path", "verbose: $verbose",
    "quiet: $quiet", "batch: $batch", "do_backup: $do_backup",
      "force_overwrite: $force_overwrite", "keep_nonmatching: $keep_nonmatching",
	"check: $check", "ignore_use_or_keyword: $ignore_use_or_keyword", "\n";
  
  unless ( -e $path ) {
    print STDERR color ('bold red');
    print STDERR "No such file: $path\n$help_str\n";
    print STDERR color ('reset');
    next;
  }

  my @files;
  if ( -d $path ) {
    my $path_fh;
    unless ( opendir $path_fh, $path ) {
      print STDERR color ('bold red');
      print STDERR "Cannot read directory $path. Check permissions.\n";
      print STDERR color ('reset');
      next;
    }

    @files = map { catfile ($path, $_) } grep { $_ !~ m/^\.\.?$/ } readdir $path_fh;
    closedir $path_fh;
  }
  elsif ( -f $path ) {
    push @files, $path;
  }
  
  for my $filename ( @files ) {
    my @processed_lines;
    my @ignored_lines;
    
    my $check = $check;
    if ( $check eq 'guess' ) {
      $check = 'use' if $filename =~ m/use/;
      $check = 'keywords' if $filename =~ m/keywords/;
      $check = 'env' if $filename =~ m/env/;
      $check = '' if $check eq 'guess';
    }
  
    my $arg_type;
    $arg_type = 'USE flag' if $check eq 'use';
    $arg_type = 'keyword' if $check eq 'keywords';
    $arg_type = 'env file' if $check eq 'env';
    
    file_preprocess ({
		      filename		=> $filename,
		      processed_lines	=> \@processed_lines,
		      ignored_lines	=> \@ignored_lines
		     });
    file_process ({
		   filename		=> $filename,
		   tmp_dir		=> $tmp_dir,
		   processed_lines	=> \@processed_lines,
		   ignored_lines		=> \@ignored_lines,
		   check			=> $check,
		   arg_type		=> $arg_type,
		   ignore_args		=> ( $check =~ m/^(use|keyword)$/ ?
					     [split /,\s*/, $ignore_use_or_keyword] :
					     [] )
		  });
  }
}

exit 0;

##################################################################################################
######################################## MAIN SUBROUTINES ########################################
##################################################################################################

##################################################################################################
# load a configuration file
sub load_config {
  ref ( my $options = shift ) eq 'HASH' or return;
  
  my $config_file = catfile ( ( $ENV{XDG_CONFIG_HOME} || catdir ($ENV{HOME}, '.config') ),
    $prog_name, "$prog_name.conf" );
  $config_file = catfile ( $ENV{HOME}, ".$prog_name.conf" ) unless -f $config_file;
  $config_file = catfile ( '/etc/', "$prog_name.conf" ) unless -f $config_file;
  return unless -f $config_file;
  
  open my $config_file_fh, '<', $config_file or die "Cannot read $config_file. Check permissions.\n";
 LINE: while ( <$config_file_fh> ) {
    chomp;
    next if $_ =~ m/^\s*(#|$)/;
    
    for my $opt ( sort keys %$options ) {
      my $opt_desc = $$options{$opt};
      my $opt_value = $$opt_desc{variable};
      
      if ( $_ =~ m/^ (?: \s* ($$opt_desc{long}) \s*
		   (?> = \s* (?:
		       true | (?<false> false | 0 ) |
		       " (?<val> [^"]+ ) " |
		       ' (?<val> [^']+ ) ' |
		       (?<val> [^ ]+ ) )
		   )? |
		   \s* (?<false> no-? ($$opt_desc{long}) ) \s*
		 )
		   $ /x ) {
	
	if ( ref $opt_value eq 'SCALAR' ) {
	  $$opt_value = ( length $+{false} ? 0 : $+{val} || 1 );
	}
	
	elsif ( ref $opt_value eq 'ARRAY' ) {
	  push @$opt_value, $+{val};
	}
	
	next LINE;
      }
    }
  }
  
  close $config_file_fh;
  check_options ($options, "Invalid configuration: $config_file");
}

##################################################################################################
# process command line
sub process_cmd {
  ref ( my $options = shift ) eq 'HASH' or return;
  my %options; # for Getopt::Long
  
  for my $opt ( sort keys %$options ) {
    my $opt_desc = $$options{$opt};
    my $key = $$opt_desc{'long'} . ( $$opt_desc{'short'} ? "|$$opt_desc{'short'}" : "" ) .
      $$opt_desc{'argument'};
    $options{$key} = $$opt_desc{'variable'}
  }
  
  GetOptions %options;
  
  for ( @ARGV ) {
    next if -f $_;
    die "No such option $_\n$help_str\n" if $_ =~ m/^-(-|.$)/;
    for my $opt ( sort keys %$options ) {
      my $opt_desc = $$options{$opt};
      die "Did you mean --$$opt_desc{long} ?\n$help_str\n"
	if $_ eq '-' . ($$opt_desc{long} =~ s/^.//r);
    }
  }
  
  check_options $options;
}

##################################################################################################
# check for invalid option arguments
sub check_options {
  ref ( my $options = shift ) eq 'HASH' or return;
  my $error = shift || "";
  
  OPT: for my $opt ( sort keys %$options ) {
    my $opt_desc = $$options{$opt};
    my $opt_value = $$opt_desc{'variable'};
    my @allowed_values = @{$$opt_desc{allowed_arguments}} or next OPT;
    
    for my $allowed_value ( @allowed_values ) {
      if ( ref $opt_value eq 'SCALAR' ) {
	next OPT if $$opt_value eq $allowed_value;
      }
      
      elsif ( ref $opt_value eq 'ARRAY' ) {
	for ( @$opt_value ) {
	  next OPT if $_ eq $allowed_value;
	}
      }
    }
    
    printmsg "$error\n" if $error;
    printmsg "Invalid option value for $$opt_desc{long}: " .
      "Choose one of @allowed_values\n";
    $$opt_value = '';
  }
	
}

##################################################################################################
# printmsg usage and exit
sub usage {
  ref ( my $options = shift ) eq 'HASH' or return;
  
  my $description = 'A script to "clean" package.* files:
  - joins entries referring to the same package-version(s),
  - removes duplicate and invalid USE flags, keywords, env files; sorts them, etc.
  - commented lines are ignored
  - also ignores lines between matching #IGNORE# lines';
  
  printmsg "$description\n\n";
  printmsg color('bold'), "Usage: ";
  printmsg color('cyan'), $prog_name;
  printmsg color('green'), " <options> [<path to files>]files";
  printmsg color('white'), "\n\nOptions:\n";
  printmsg color('reset');
  
  for my $opt ( sort keys %$options ) {
    my $opt_desc = $$options{$opt};
    
    printl ({
	     text => "--$$opt_desc{long}",
	     justify => 'left',
	     left_column_width => ($left_column_width - 10)
	    });
    
    if ( length $$opt_desc{long} > ($left_column_width - 10) ) {
      printmsg "\n" . " " x ($left_column_width -10 + $tab_width);
    }
    
    printmsg (( $$opt_desc{short} ? "-$$opt_desc{short}" : "  " ) . " " x 8);
    
    printr ({
	     text => $$opt_desc{description},
	     left_column_width => ($left_column_width + $tab_width)
	    });
    
    printmsg "\n";
  }
  
  printmsg "\n";
  printmsg "If ";
  printmsg color('bold green'), "file";
  printmsg color('reset');
  printmsg " is a directory, all files inside it are processed\n";
  printmsg "If not specified, path defaults to ";
  printmsg color('bold green'), "/etc/portage/\n";
  printmsg color('reset');
  printmsg "If you want to clean files in the current directory, use ";
  printmsg color('bold cyan'), "$prog_name <options> ./files\n";
  printmsg color('reset');
  printmsg "If file's name begins with -, use ";
  printmsg color('bold cyan'), "$prog_name <options> -- files\n";
  printmsg color('reset');
  printmsg "If found, a configuration file is read from " .
    "~/.$prog_name.conf, ~/.conf/$prog_name/$prog_name.conf or /etc/$prog_name.conf\n";
#  printmsg "If you encounter a bug, use the -D option, save the output to a file and report.\n";
  
  exit 0;
}

##################################################################################################
# read file and preprocess (sort and decide which lines to ignore)
sub file_preprocess {
  my $filename = ${$_[0]}{filename} or die;
  my $lines = ${$_[0]}{processed_lines} or die;		# lines to be processed, default
  my $lines_ignored = ${$_[0]}{ignored_lines} or die;	# lines to be ignored, i.e. inside an '#IGNORE#' block
  
  my @lines_preprocessed;				# lines to be preprocessed here, default
  my $ignore = 0;					# true if inside an '#IGNORE#' block
  
  # open file for reading
  my $file_fh;
  unless ( open $file_fh, '<', "$filename" ) {
    print STDERR color ('bold red');
    print STDERR "Cannot read $filename. Check permissions.\n";
    print STDERR color ('reset');
    return;
  }
  
  while ( <$file_fh> ) {
    chomp;
    printdbg "line preprocess: $_";
    if ( $_ =~ m/^\s*#IGNORE#\s*$/ ) {
      push @$lines_ignored, $_; # block delimiters are always stored as ignored lines
      $ignore = $ignore ^ 1;	# toggle ignoring state
      printdbg "ignore block " . ( $ignore ? "begins" : "ends" );
      next;
    }
    
    if ( $ignore ) {
      push @$lines_ignored, $_;
    } else {
      push @lines_preprocessed, $_;
    }
  }
  close $file_fh;
  
  # sort the original file ignoring any lines between matching '#IGNORE#' lines (saving them for later)
  for ( sort {($a =~ s/^\s*(?:#\s*|[<>=~!]+)//r)
		cmp ($b =~ s/^\s*(?:#\s*|[<>=~!]+)//r)}
	map { chomp; $_ } @lines_preprocessed ) {
    printdbg "\n", "line sort: $_";
    
    $_ =~ s/^\s+|\s+$//g;  # remove leading, trailing and extra spaces/tabs
    
    # if it's the first element, or it is a comment, or it is a glob, store it and continue
    if ( ! @$lines || $_ =~ m/^#/ ) {
      printdbg "first or comment";
      push @$lines, $_ ;
      next;
    }
    
    # otherwise, compare it with previous element, unless it was a comment
    if ( $$lines[-1] =~ m/^#/ ) {
      printdbg "previous line was a comment";
      push @$lines, $_ ;
      next;
    }
    
    ## join them if they refer to the same [prefix]package[-version]
    my ($current, @args) = split /\s+/, $_ || [""];
    my $previous = (split /\s+/, $$lines[-1])[0] || "";
    printdbg "current: $current";
    printdbg "previous: $previous";
    
    if ( $previous eq $current) {
      $$lines[-1] .= " @args" if @args;
      printdbg "joining as $$lines[-1]";
      next;
    }
    
    ## otherwise just store it
    push @$lines, $_;
  }
  
  printdbg "\n", "Final lines to be further processed:";
  printdbg $_ for @$lines;
}

##################################################################################################
# main processing of file
sub file_process {
  my $filename = ${$_[0]}{filename} or die;
  my $tmp_dir = ${$_[0]}{tmp_dir} or die;
  my $lines = ${$_[0]}{processed_lines} or die;		# lines to be processed, default
  my $lines_ignored = ${$_[0]}{ignored_lines} or die;	# lines to be ignored, i.e. inside an '#IGNORE#' block
  my $check = ${$_[0]}{check} || "";
  my $arg_type = ${$_[0]}{arg_type} || "";
  ref (my $ignore_args =
       ${$_[0]}{ignore_args}) eq 'ARRAY' or die;
  
  unless ( $arg_type ) {
    $arg_type = 'USE flag' if $check eq 'use';
    $arg_type = 'keyword' if $check eq 'keywords';
    $arg_type = 'env file' if $check eq 'env';
  }
  
  # set tmp filename
  my ($filetmp_fh, $filename_tmp) = tempfile ( DIR => $tmp_dir, UNLINK => 0 );
  
  printmsg color('bold cyan');
  printl { text => "Processing file:" };
  printmsg $filename;
  printl { text => "Temporary file:" };
  printmsg $filename_tmp;
  if ( $check ) {    
    printl { text => "Checking:" };
    printmsg "${arg_type}s";
  }
  printmsg color('reset');
  printmsg "\n";
  
  # open filetmp for writing
  open $filetmp_fh, '>', "$filename_tmp"
    or die "Cannot write to $filename_tmp, check directory permissions.\n";
  
  # process all lines
  for my $entry ( @$lines ) {
    printdbg "\n", "line: $entry";
    
    # remove empty lines
    if ( $entry =~ m/^$/ ) {
      printdbg "empty";
      next;
    }
    
    printmsg "\n" if $verbose;
    
    # ignore commented lines
    if ( $entry =~ m/^#/ ) {
      if ( $verbose ) {
	printmsg color('bold', 'green');
	printl { text => "Skipping commented line:" };
	printmsg $entry;
	printmsg color('reset');
      }
      printdbg "comment";
      print $filetmp_fh "$entry\n";
      next;
    }
    
    # get package atom properties
    my ($atom, @args) = split /\s+/, $entry;
    my $pkg = get_atom_props $entry;
        
    if ( $verbose ) {
      printl { text => "Processing entry for:" };
      printmsg $$pkg{name};
      printl { text => "Version listed is:" };
      printmsg $atom =~ s/\Q$$pkg{name}\E-?//r;
    }
    
    unless ( $$pkg{name} =~ m|/| ) {
      print STDERR color ('bold red');
      print STDERR "Invalid entry for $atom - atoms must contain a category and package name! See ebuild(5)\n";
      print STDERR  color ('reset');
      next;
    }
    
    if ( length $$pkg{version} && ! length $$pkg{rule} ) {
      print STDERR color ('bold red');
      print STDERR "Invalid entry for $atom - atoms referring to a version must have a prefix! See ebuild(5)\n";
      print STDERR  color ('reset');
      next;
    }
    
    if ( length $$pkg{rule} && ! length $$pkg{version} ) {
      print STDERR color ('bold red');
      print STDERR "Invalid entry for $atom - atoms with prefix must refer to a version! See ebuild(5)\n";
      print STDERR  color ('reset');
      next;
    }
    
    my $matching_versions = is_installed $pkg;
    
    unless ( $matching_versions || $keep_nonmatching ) {
      not_installed $atom;
      next;
    }
    
    unless ( $check ) {
      print $filetmp_fh "$entry\n";
      next;
    }
    
    # check USE flags, keywords or env files
    
    # if we're keeping non-matching entries, make sure get_atom_args
    # gets an ARRAY ref - its contents do not affect 'env' checking
    #
    # get_atom_args will return null if it gets an empty
    # versions array for USE or keyword checking
    my $matching_args = get_atom_args ({
					matching_versions	=> $matching_versions || [],
					check			=> $check
				       });

    my $valid_args;
    if ( $matching_args ) {
      # entry has a matching version installed or check is 'env'
      # get_valid_atom_args will never return null
      $valid_args = get_valid_atom_args ({
				      matching_args	=> $matching_args,
				      atom		=> $atom,
				      check		=> $check,
				      args		=> \@args,
				      arg_type		=> $arg_type,
				      ignore_args	=> $ignore_args
				     });
    }
    
    # check is 'env' or there are macthing versions installed
    if ( $valid_args ) {
      # valid args found
      if ( @$valid_args ) {
	printl { text => "$atom", justify => 'left', out => $filetmp_fh };
	printr { text => "@$valid_args", right_column_width => 1000, out => $filetmp_fh };
	print $filetmp_fh "\n";
	next;
      }
      
      # else, if check is 'use', remove entry
      elsif ( $check eq 'use' ) {
	no_use $atom;
	next;
      }
      
      # else just printmsg the atom
      print $filetmp_fh "$atom\n";
      next;
    }
    
    # check is not 'use' or 'keyword' and there is no macthing version installed
    # printmsg the original args listed if any
    if ( @args ) {
      printl { text => "$atom", justify => 'left', out => $filetmp_fh };
      printr { text => "@args", right_column_width => 1000, out => $filetmp_fh };
      print $filetmp_fh "\n";
      next;
    }
    
    # else, if check is 'use', remove entry
    elsif ( $check eq 'use' ) {
      no_use $atom;
      next;
    }
    
    # else just printmsg the atom
    print $filetmp_fh "$atom\n";
  }
  
  print $filetmp_fh "\n" if @$lines_ignored;
  print $filetmp_fh "$_\n" for @$lines_ignored;
  close $filetmp_fh;
  
  printmsg "\n";
  printmsg "\n" if $verbose;
  print "\n" if $quiet && ! $batch;
  
  my $overwrite;
  
  if ( $force_overwrite ) { $overwrite = 'y'; }
  else {
    $overwrite = prompt ({
			  prompt		=> "Changes have been saved to $filename_tmp. " .
			  "Overwrite $filename? (yes/no) ",
			  prompt_invalid	=> "Please answer with yes (y) or no (n) "
			 });
  }
  
  if ( $overwrite =~ /y/ ) {
    my $mode = (stat $filename)[2] & 07777;
    my ($uid, $gid) = (stat $filename)[4,5];
    
    if ( $do_backup ) {
      unless ( mv $filename, $filename . '~' ) {
	 print STDERR color ('bold red');
	 print STDERR "\nCannot backup $filename to $filename~. Check permissions.\n";
	 print STDERR color ('reset');
	 return;
       }
    }
    
    mv $filename_tmp, $filename or print STDERR color ('bold red'),
      "\nCannot overwrite $filename. Check permissions.\n", color ('reset');
    chmod $mode | 0600, $filename;
    chown $uid, $gid, $filename;
  }
}

##################################################################################################
############################################# HELPERS ############################################
##################################################################################################

##################################################################################################
# get atom prefix, package name, version, slot, subslot and USE flags/keywords/env files
sub get_atom_props {
  my $entry = shift;
  
  $entry =~ m!(?(DEFINE)
		# matches a vesion (excluding release, patch, revision)
		# number with an optional * at the end
		(?<version_glob> (?> \d+ (?> \.\d+ )* (?> \.?\* | [a-z] \*? )? | \* ) )
		# matches a slot or a subslot with an optional * at the end
		(?<slot_glob> (?> [a-z0-9_] [a-z0-9._-]* \*? | \* ) ) )
	      
	      ^(?<rule> \!? [<>]? [=~]? )				# atom prefix
	      (?<name> [a-z0-9-*]+/[a-zA-Z0-9-_*]+? )			# category/name
	      (?> - (?<full_version>					# full version
		  (?<version> (?&version_glob) )			# version
		  (?> _ (?<release> (?: alpha | beta | pre | rc ) \d* ) )?  	# release
		  (?> _p (?<patch>    \d+ ) )?				# patch
		  (?> -r (?<revision> \d+ ) )?				# revision
	      ) )?
	      (?> :
		(?<slot> (?&slot_glob) )				# slot number
		(?> / (?<subslot> (?&slot_glob) ) )?			# subslot number (only if slot present)
	      )?
	      (?> :: (?<repository> .* ) )?				# repository
	      (?> \s+ (?<args> .* ) )?					# anything following the atom
	     $ !x;
  
  my $rule = $+{rule} || "";
  my $name = $+{name} || "";
  my $full_version = $+{full_version};
  $full_version = "" unless length $full_version;
  my $version = $+{version};
  $version = "" unless length $version;
  my $release = $+{release} || "";
  my $patch = $+{patch};
  $patch = "" unless length $patch;
  my $revision = $+{revision};
  $revision = "" unless length $revision;
  my $slot = $+{slot};
  $slot = "" unless length $slot;
  my $subslot = $+{subslot};
  $subslot = "" unless length $subslot;
  my $repository = $+{repository} || "";
  my $args = [split (' ', $+{args} || "")];
  
  printdbg "get_atom_props: rule: $rule " .
    "name: $name " .
      "version: $version " .
	"release: $release " .
	  "patch: $patch " .
	    "revision: $revision " .
	      "slot: $slot " .
		"subslot: $subslot " .
		  "repository $repository";
  printdbg "get_atom_props: " . scalar @$args . " args: @$args";
  
  return {
	  rule		=> $rule,
	  name		=> $name,
	  full_version	=> $full_version,
	  version	=> $version,
	  release	=> $release,
	  patch		=> $patch,
	  revision	=> $revision,
	  slot		=> $slot,
	  subslot	=> $subslot,
	  repository	=> $repository,
	  args		=> $args
	 };
}

##################################################################################################
# check if package is installed
sub is_installed {
  ref (my $pkg = shift) eq 'HASH' or die;
  my ( $rule, $name, $version, $slot, $subslot, $repository ) =
    ( $$pkg{rule}, $$pkg{name}, $$pkg{full_version}, $$pkg{slot}, $$pkg{subslot}, $$pkg{repository} );
  
  # check if package is installed at all and discard it if not
  my $db_dir = "/var/db/pkg/";
  die "Cannot read $db_dir, check directory permissions.\n" unless -x $db_dir && -r $db_dir;
  
  my @installed_versions;
  {
    my ($category, $name) = split '/', $name;
    printdbg "cat, name: $category, $name";
    my @categories = File::Find::Rule
      ->relative
      ->maxdepth( 1 )
      ->directory
      ->name( $category )
      ->in( $db_dir );
    printdbg "matching categories: @categories";
    
    for my $cat ( @categories ) {
      my @matches = File::Find::Rule
	->relative
	->maxdepth( 1 )
	->directory
	->name( $name . '*' ) # needed because directory names contain the version at the end
	->in( catdir ($db_dir, $cat) );
      printdbg "matching names in $cat: @matches";
      push @installed_versions, catdir ($cat, $_) for @matches;
    }
    
    # from all the found entries get only those whose name matches the listed one
    # (unless it's a glob) for the category of the found entry
    @installed_versions = grep { ${&get_atom_props($_)}{name} eq ($_ =~ s![^/]+$!!r) . $name }
      @installed_versions unless $name =~ m/\*/;
  }
  
  unless ( @installed_versions ) {
    printdbg "not installed at all";
    return;
  }
  
  my @matching_versions;
  for ( @installed_versions) {
    my ($installed_name, $installed_version) = @{&get_atom_props($_)}{"name", "full_version"};
    my $installed_repository = "";
    
    open my $slotfile_fh, '<', catfile ( $db_dir, $_, "SLOT" ) or die;
    
    my ($installed_slot, $installed_subslot) = split '/', <$slotfile_fh>;
    $installed_subslot = "" unless $installed_subslot;
    chomp ($installed_slot, $installed_subslot);
    
    close $slotfile_fh;
    $installed_subslot = $installed_subslot || $installed_slot;
    
    if ( $repository ) {
      open my $repfile_fh, '<', catfile ( $db_dir, $_, "repository" ) or die;
      chomp ($installed_repository = <$repfile_fh>);
      close $repfile_fh;
    }
    
    printdbg "installed version: $installed_version:$installed_slot/$installed_subslot " .
      "installed repository: $installed_repository";
    
    # check that repository matches
    if ( $repository && $repository ne $installed_repository ) {
      printdbg "repository mismatch";
      next;
    }
    
    # check that version installed matches that listed
    if ( length $version ) {
      printdbg "comparing versions:";
      unless ( version_or_slot_matches ({
					 listed		=> $version,
					 installed	=> $installed_version,
					 rule		=> $rule
					}) ) {
	printdbg "version mismatch $installed_version $rule $version";
	next;
      }
    }
    
    # check that slot installed equals that listed
    if ( length $slot ) {
      printdbg "comparing slots";
      unless ( version_or_slot_matches ({
					 listed		=> $slot,
					 installed	=> $installed_slot,
					 rule		=> '='
					}) ) {
	printdbg "slot mismatch $installed_slot vs $slot";
	next;
      }
    }
    
    # check that subslot installed equals that listed
    if ( length $subslot ) {
      printdbg "comparing subslots";
      unless ( version_or_slot_matches ({
					 listed		=> $subslot,
					 installed	=> $installed_subslot,
					 rule		=> '='
					}) ) {
	printdbg "subslot mismatch $installed_subslot vs $subslot";
	next;
      }
    }
    
    push @matching_versions, $_;
    printdbg "matched version: $_";
  }
  
  return \@matching_versions if @matching_versions;
  printdbg "failed to match";
  return;
}

##################################################################################################
# get valid arguments for a package version
sub get_atom_args {
  ref (my $matching_versions = ${$_[0]}{matching_versions}) eq 'ARRAY' or die;
  my $check = ${$_[0]}{check} || "";
  my @matching_args;
  
  if ( $check =~ m/^(use|keywords)$/ ) {
    return unless @$matching_versions; # pkg is not installed
    
    my $db_dir = "/var/db/pkg/";
    my $arg_file;
    $arg_file = 'IUSE' if $check eq 'use';
    $arg_file = 'KEYWORDS' if $check eq 'keywords';
    
    for ( @$matching_versions ) {
      if ( open my $argsfile_fh, '<', catfile ($db_dir, $_, $arg_file) or return ) {
	push @matching_args, split (' ', <$argsfile_fh>);
	close $argsfile_fh;
	
	printdbg "matching version: $_" .
	  scalar @matching_args . " valid args: @matching_args";
      }
    }
    
    if ( $check eq 'use' ) {
      $_ =~ s/^[+-]// for @matching_args; # remove + and - in front of USE flags
    } elsif ( $check eq 'keywords' ) {
      push @matching_args, '*';
      push @matching_args, '**';
      push @matching_args, '~*';
    }
    
    remove_dup_args @matching_args;
    
  } elsif ( $check eq 'env' ) {
    printdbg "getting env files";
    
    opendir my $envdir_fh, "/etc/portage/env" or return;
    @matching_args = grep { $_ !~ m/^\.\.?$/ } readdir $envdir_fh;
    closedir $envdir_fh
  }
  
  return \@matching_args;
}

##################################################################################################
# check for valid use flags, keywords, env files
sub get_valid_atom_args {
  ref (my $matching_args = ${$_[0]}{matching_args}) eq 'ARRAY' or die;
  my $atom = ${$_[0]}{atom} or die;
  my $check = ${$_[0]}{check} || "";
  ref (my $args = ${$_[0]}{args}) eq 'ARRAY' or die;
  my $arg_type = ${$_[0]}{arg_type} || "";
  ref (my $ignore_args = ${$_[0]}{ignore_args}) eq 'ARRAY' or die;
  
  unless ( $arg_type ) {
    $arg_type = 'USE flag' if $check eq 'use';
    $arg_type = 'keyword' if $check eq 'keywords';
    $arg_type = 'env file' if $check eq 'env';
  }
  
  unless ( @$args ) {
    printdbg "no args at all";
    return [];
  }
  
  if ( $verbose ) {
    printl { text => "Valid ${arg_type}s:" };
    printr { text => "@$matching_args" };
    printl { text => "Listed ${arg_type}s:" };
    printr { text => "@$args" };
  }
  
  # check if args are valid
  my @valid_args;
 ARG: for ( @$args ) {
    for my $valid_arg ( ( @$matching_args, @$ignore_args ) ) {
      printdbg "$valid_arg vs $_";
      if ( $_ eq $valid_arg ||
	 ( $_ =~ m/^[+-]?\Q$valid_arg\E/ && $check eq 'use' ) ) {
	printdbg "arg $_ is valid";
	push @valid_args, $_;
	next ARG;
      }
    }
    printdbg "arg $_ is invalid";
    invalid_arg ({
		  arg		=> $_,
		  arg_type	=> $arg_type,
		  pkg_name	=> $atom
		  });
  }
  
  remove_dup_args @valid_args,
    ( $batch ? "" : "\nContradicting ${arg_type}s: \%1, \%2 listed for " . $atom );
  printdbg "valid args: @valid_args";
  
  return \@valid_args;
}

##################################################################################################
# check if version, slot or subslot in listed atom matches installed version,
# slot or subslot (taking into account atom prefix)
sub version_or_slot_matches {
  my $listed = ${$_[0]}{listed};
  my $installed = ${$_[0]}{installed};
  my $rule = ${$_[0]}{rule} or die;	# atom prefix
  length $listed && length $installed or die;
  
  # negate the result if the atom prefix requires
  my $match;
  my $mismatch;
  if ( $rule =~ m/!/ ) { $mismatch = 1; }
  else { $match = 1; }
  
  printdbg "$listed vs $installed, rule is $rule";
  return $match if $listed eq '*';	# any version, slot or subslot is accepted
  
  # check equality first, if acceptable
  if ( $rule =~ m/=/ ) {
    return $match if
      version_or_slot_equals ({
			       listed		=> $listed,
			       installed	=> $installed
			      });
  }
  return $mismatch unless $rule =~ m/[><~]/;
  
  # NOTE: only version comparison should reach this point as
  # slot numbers in atoms must be equal to installed ones
  
  # if not and if any revision number is acceptable, try to equate base versions
  if ( $rule =~ m/~/ ) {
    printdbg "trying to equate base versions...";
    $listed =~ s/-r\d+$//;
    $installed =~ s/-r\d+$//;
    return $match if
      version_or_slot_equals ({
			       listed		=> $listed,
			       installed	=> $installed
			      });
  }
  return $mismatch unless $rule =~ m/[><]/;
  
  # else, if acceptable, remove globs and check precedence of versions
  printdbg "checking precedence of versions";
  $listed =~ s/\.?\*.*//;
  my $lower = get_lower_version $listed, $installed;
  die unless length $lower;
  
  return $match if $rule =~ m/>/ && $listed eq $lower;
  return $match if $rule =~ m/</ && $installed eq $lower;
  return $mismatch;
}

##################################################################################################
# check if installed version number equals listed one (taking into account globbing)
sub version_or_slot_equals {
  my $listed = ${$_[0]}{listed};
  my $installed = ${$_[0]}{installed};
  length $listed && length $installed or die;
  
  printdbg "trying to equate...";
  return 1 if $installed eq $listed; # exact equality
  
  # if not, remove any possible globbing pattern and continue checks
  printdbg "  fail";
  
  if ( $listed =~ m/\*/ ) {
    printdbg "glob pattern, trying to equate...";
    
    $listed =~ s/\.?\*.*//;
    return 1 if $installed =~ m/^\Q$listed\E/;
  }
  
  printdbg "  fail";
  return;
}

##################################################################################################
# return the lower of the two versions
sub get_lower_version {
  my $pkg1 = shift;
  my $pkg2 = shift;
  length $pkg1 && length $pkg2 or die;
  
  # separate version parts, e.g. 4.3a_beta-r1 -> 4.3a, beta, r1
  my $v1 = get_atom_props "dummy/name-" . $pkg1;
  my $v2 = get_atom_props "dummy/name-" . $pkg2;
  
  # compare base version numbers
  # optional letter following the version
  {
    my $base1 = $$v1{version};
    my $base2 = $$v2{version};
    my $base1_suff = "";
    my $base2_suff = "";
    
    if ( $base1 =~ s/([a-z])$// ) { $base1_suff = $1; }
    if ( $base2 =~ s/([a-z])$// ) { $base2_suff = $1; }
    printdbg "base comparison: $base1 vs $base2";
    
    while ( length $base1 || length $base2 ) {
      my $base1_part = "";
      my $base2_part = "";
      if ( $base1 =~ s/^(\d+)\.?// ) { $base1_part = $1; }
      if ( $base2 =~ s/^(\d+)\.?// ) { $base2_part = $1; }
      
      last unless length $base1_part || length $base2_part;
      
      # any number > 0 is a higher version than none
      return $pkg1 if length $base2_part && ! length $base1_part;
      return $pkg2 if length $base1_part && ! length $base2_part;
      
      printdbg "base: $base1_part vs $base2_part";
      return $pkg1 if $base1_part < $base2_part;
      return $pkg2 if $base2_part < $base1_part;
      
    }
    
    printdbg "base suffix comparison: $base1_suff vs $base2_suff";
    return $pkg1 if $base1_suff lt $base2_suff;
    return $pkg2 if $base2_suff lt $base1_suff;
  }
  
  # if they're equal, compare releases
  {
    # precedence of releases
    my @ordered_releases = ('alpha', 'beta', 'pre', 'rc', '' );
    printdbg "release comparison part1: $$v1{release}, $$v2{release}";
    
    # any release is a lower version than none
    return $pkg1 if length $$v1{release} && ! length $$v2{release};
    return $pkg2 if length $$v2{release} && ! length $$v1{release};
    
    my ( $rel1_precedence ) = grep { $$v1{release} =~ m/^\Q$ordered_releases[$_]\E/ }
      0 .. $#ordered_releases;
    my ( $rel2_precedence ) = grep { $$v2{release} =~ m/^\Q$ordered_releases[$_]\E/ }
      0 .. $#ordered_releases;
    printdbg "$rel1_precedence vs $rel2_precedence";
    
    return $pkg1 if $rel1_precedence < $rel2_precedence;
    return $pkg2 if $rel2_precedence < $rel1_precedence;
    
    my $release1_num = $$v1{release} =~ s/^[a-z]+//r;
    my $release2_num = $$v2{release} =~ s/^[a-z]+//r;
    printdbg "release comparison part2: $release1_num, $release2_num";

    if ( length $release1_num || length $release2_num ) {
      
      # any release number is a higher version than none
      return $pkg1 if length $release2_num && ! length $release1_num;
      return $pkg2 if length $release1_num && ! length $release2_num;
      
      return $pkg1 if $release1_num < $release2_num;
      return $pkg2 if $release2_num < $release1_num;
    }
  }
  
  # if they're equal, compare patch numbers
  if ( length $$v1{patch} || length $$v2{patch} ) {
    printdbg "patch comparison part1: $$v1{patch}, $$v2{patch}";
    
    # any patch is a higher version than none
    return $pkg1 if length $$v2{patch} && ! length $$v1{patch};
    return $pkg2 if length $$v1{patch} && ! length $$v2{patch};
    
    printdbg "patch number comparison";
    return $pkg1 if $$v1{patch} < $$v2{patch};
    return $pkg2 if $$v2{patch} < $$v1{patch};
  }
  
  # finally, if they're equal, compare revision numbers
  if ( length $$v1{revision} || length $$v2{revision} ) {
    printdbg "revision number comparison: $$v1{revision} vs $$v2{revision}";
    
    # any revision is a higher version than none
    return $pkg1 if length $$v2{revision} && ! length $$v1{revision};
    return $pkg2 if length $$v1{revision} && ! length $$v2{revision};
    
    return $pkg1 if $$v1{revision} < $$v2{revision};
    return $pkg2 if $$v2{revision} < $$v1{revision};
  }
  
  printdbg "equal";
  return; # they're equal
}

##################################################################################################
# sort and remove duplicate elements in array ignoring leading +/- (for USE flags)
sub remove_dup_args (\@;$) {
  ref (my $array = shift) eq 'ARRAY' or die;
  my $prompt = shift || "";
  return $array if @$array < 2;
  
  @$array = sort {($a =~ s/^[+-]//r) cmp ($b =~ s/^[+-]//r)} @$array; # sort the elements
  printdbg "sorted elements: @$array";
  
  my $elem = 1;
  while ( $$array[$elem] ) {
    my $current = $$array[$elem] =~ s/^\+//r;
    my $previous = $$array[$elem - 1] =~ s/^\+//r;
    
    if ( $current =~ s/^-//r eq $previous =~ s/^-//r ) {
      if ( $prompt && $current ne $previous ) {
	$prompt =~ s/%1/$previous/g;
	$prompt =~ s/%2/$current/g;
	$prompt .= "\nPlease choose action (1: keep former, 2: keep latter, 3: remove both) ";
	printdbg "duplicate element: $current vs $previous";

	my $in;
	if ( $batch ) { $in = 1; }
	
	else { $in = prompt ({
			      prompt		=> $prompt,
			      prompt_invalid	=> 'Please answer with 1, 2 or 3 ',
			      allowed_replies	=> [ '1', '2', '3' ]
			     });
	     }
	splice @$array, $elem, 1 if $in == 1;
	splice @$array, $elem - 1, 1 if $in == 2;
	splice @$array, $elem - 1, 2 if $in == 3;
      }
      
      else {      
	printdbg "duplicate element: $current vs $previous";
	splice @$array, $elem, 1;
      }
    }
    
    else {
      $elem++;
    }
  }
  
  return $array;
}

##################################################################################################
######################################### PRINT MESSAGES #########################################
##################################################################################################

##################################################################################################
# printmsg a message for packages with no installed versions matching atom
sub not_installed {
  my $entry = shift or die;
  
  if ( $verbose ) {
    printmsg color('bold', 'red');
    printmsg "\nNo matching version installed, deleting entry.";
    printmsg color('reset');
  }
  
  else {
    printmsg color('bold', 'red');
    printl { text => "No matching version installed for:" };
    printmsg $entry;
    printl { text => "Deleting entry." };
    printmsg "\n";
    printmsg color ('reset');
  }
  
  return 1;
}

##################################################################################################
# printmsg a message for packages with no valid use flags
sub no_use {
  my $entry = shift or die;
  
  if ( $verbose ) {
    printmsg color('bold', 'red');
    printmsg "\nNo USE flags listed, deleting entry.";
    printmsg color('reset');
  }
  
  else {
    printmsg color('bold', 'red');
    printl { text => "No USE flags listed for:" };
    printmsg $entry;
    printl { text => "Deleting entry." };
    printmsg "\n";
    printmsg color ('reset');
  }
  
  return 1;
}

##################################################################################################
# printmsg a message for invalid args
sub invalid_arg {
  my $arg = ${$_[0]}{arg} or die;
  my $arg_type = ${$_[0]}{arg_type} or die;
  my $pkg_name = ${$_[0]}{pkg_name} or die;
  
  if ( $verbose ) {
    printmsg color('bold', 'red');
    printmsg "\nInvalid $arg_type $arg, deleting it.";
    printmsg color('reset');
  }
  
  else {
    printmsg color('bold', 'red');
    printl { text => "No such $arg_type:" };
    printmsg $arg;
    printl { text => "for versions matching:" };
    printmsg $pkg_name;
    printl { text => "Deleting $arg_type." };
    printmsg "\n";
    printmsg color('reset');
  }
  
  return 1;
}

##################################################################################################
# printmsg a string of text into the left column, justifying it
sub printl {
  ref (my $options = shift) eq 'HASH' or die;
  my $text = $$options{text} || "";				# text to be printmsged
  my $left_column_width = $$options{left_column_width} ||
    $left_column_width;						# width of left column
  my $tab_width = $$options{tab_width} || $tab_width;		# separation of left and right columns
  my $justify = $$options{justify} || 'right';			# justification
  my $out_fh = $$options{out} || *STDOUT;

  return if $quiet && $out_fh eq *STDOUT;
  
  printmsg "\n" if $out_fh eq *STDOUT;
  
  my $txt_lgth = length $text;
  
  if ( $txt_lgth < $left_column_width ) {
    print $out_fh " " x ( $left_column_width - $txt_lgth ) . $text . " " x $tab_width if $justify eq 'right';
    print $out_fh $text . " " x ( $left_column_width - $txt_lgth ) . " " x $tab_width if $justify eq 'left';
  }
  
  elsif ( $txt_lgth < $left_column_width + $tab_width ) {
    print $out_fh $text . " " x ( $left_column_width + $tab_width - $txt_lgth );
  }
  
  else {
    print $out_fh $text . " ";
  }
  
  return 1;
}

##################################################################################################
# printmsg a long string of text into the right column, separating it in lines and applying tabbing
sub printr {
  ref (my $options = shift) eq 'HASH' or die;
  my $text = $$options{text} || "";				# text to be printmsged
  my $left_column_width = $$options{left_column_width} ||
    $left_column_width + $tab_width;				# width of left column + tab
  my $right_column_width = $$options{right_column_width} ||
    $right_column_width;					# width of right column
  my $out_fh = $$options{out} || *STDOUT;

  return if $quiet && $out_fh eq *STDOUT;
  
  my $row_num = 0;
  my $line = '';
  
  for ( split //, $text ) {
    if ( floor ( ( length($line) + $left_column_width ) /
		       ( $right_column_width + $left_column_width )
		     ) == $row_num
	 || $_ ne ' ' ) {
      $line .= "$_";
      next;
    }		 # still on the same row (or inside a word), just add a char and continue
    $line .= "\n" . " " x $left_column_width; # else, continue on a newline
    $row_num++;
  }
  
  print $out_fh $line;
  return 1;
}

##################################################################################################
# printmsg a debugging message
sub printdbg {
  return if $quiet || ! $debug;
  printmsg "debug: $_" . ($_ eq "\n" ? "" : "\n") for @_;
}

##################################################################################################
# printmsg unless quiet mode is on
sub printmsg {
  return if $quiet;
  print $_ for @_;
}

##################################################################################################
# prompt the user for input
sub prompt {
  my $prompt = ${$_[0]}{prompt} or die;
  my $prompt_invalid = ${$_[0]}{prompt_invalid} || $prompt;
  my $allowed_replies = ${$_[0]}{allowed_replies} || [ 'yes', 'y', 'no', 'n' ];
  die unless ref $allowed_replies eq 'ARRAY';
  
  print color('bold yellow');
  print $prompt;
  print color('reset');
  
  chomp (my $in = <STDIN>);
  $in =~ s/^\s+|\s+$//g;
  
  for ( @$allowed_replies ) {
    return $in if $in eq $_;
  }
  
  prompt ({
	   prompt		=> $prompt_invalid,
	   allowed_replies	=> $allowed_replies
	  });
}
